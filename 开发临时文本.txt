可选头 31 个字段
IMAGE_OPTIONAL_HEADER32
Optional_Header
    //
    // Standard fields.
    //
    WORD    Magic;
    BYTE    MAJORLINKERVERSION;
    BYTE    MINORLINKERVERSION;
    DWORD   SIZEOFCODE;
    DWORD   SIZEOFINITIALIZEDDATA;
    DWORD   SIZEOFUNINITIALIZEDDATA;
    DWORD   ADDRESSOFENTRYPOINT;
    DWORD   BASEOFCODE;
    DWORD   BASEOFDATA;

    //
    // NT additional fields.
    //

    DWORD   ImageBase;
    DWORD   SectionAlignment;
    DWORD   FileAlignment;
    WORD    MajorOperatingSystemVersion;
    WORD    MinorOperatingSystemVersion;
    WORD    MajorImageVersion;
    WORD    MinorImageVersion;
    WORD    MajorSubsystemVersion;
    WORD    MinorSubsystemVersion;
    DWORD   Win32VersionValue;
    DWORD   SizeOfImage;
    DWORD   SizeOfHeaders;
    DWORD   CheckSum;
    WORD    Subsystem;
    WORD    DllCharacteristics;
    DWORD   SizeOfStackReserve;
    DWORD   SizeOfStackCommit;
    DWORD   SizeOfHeapReserve;
    DWORD   SizeOfHeapCommit;
    DWORD   LoaderFlags;
    DWORD   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
	
文件头 7 个字段
typedef struct _IMAGE_FILE_HEADER {
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;


IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER)        \
    ((ULONG_PTR)(ntheader) +                                            \
     FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +                 \
     ((ntheader))->FileHeader.SizeOfOptionalHeader   \
    ))

#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory info
#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory Info
#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory
#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory
#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table
#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory
//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)
#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP
#define IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers
#define IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table
#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors
#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor

在DataDirectory 对话框中，可以添加如下几个按扭：
1. 导出表 2.导入表 3.资源表 4.重定位表

typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    union {
        DWORD   Characteristics;            // 0 for terminating null import descriptor
        DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
    } DUMMYUNIONNAME;
    DWORD   TimeDateStamp;                  // 0 if not bound,
                                            // -1 if bound, and real date\time stamp
                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
                                            // O.W. date/time stamp of DLL bound to (Old BIND)

    DWORD   ForwarderChain;                 // -1 if no forwarders
    DWORD   Name;
    DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)
} IMAGE_IMPORT_DESCRIPTOR;

VOID ShowImportFunctions(HWND hWnd,int index)
{
	PIMAGE_DOS_HEADER pDH = (PIMAGE_DOS_HEADER)mfs.ImageBase;
	PIMAGE_NT_HEADERS pNtH = (PIMAGE_NT_HEADERS)((DWORD)pDH + pDH->e_lfanew);
	PIMAGE_IMPORT_DESCRIPTOR pID = NULL;
	PIMAGE_THUNK_DATA pTD = NULL;
	PIMAGE_IMPORT_BY_NAME pIBN = NULL;
	DWORD dwOffset;
	HWND hList;
	LVITEMA lvItem;
	char szBuffer[128];
	size_t i;

	// 设定list的格式
	hList = GetDlgItem(hWnd, IDC_LIST_IMPORTFUNCTIONS);
	SendMessage(hList, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, (LPARAM)LVS_EX_FULLROWSELECT);
	SendMessage(hList, LVM_DELETEALLITEMS, 0, 0);

	// 获取PID的地址
	Rva2offset(mfs.ImageBase, pNtH->OptionalHeader.DataDirectory[1].VirtualAddress, &dwOffset);
	pID = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)mfs.ImageBase + dwOffset) + index;
	
	//获取OriginalFirstThunk的地址
	Rva2offset(mfs.ImageBase, pID->OriginalFirstThunk, &dwOffset);
	if (0 == *(PDWORD)((DWORD)mfs.ImageBase + dwOffset))
	{
		// 如果指向的内容为0，则把当前的指向FirstThunk
		Rva2offset(mfs.ImageBase, pID->FirstThunk, &dwOffset);
	}
	pTD = (PIMAGE_THUNK_DATA)((DWORD)mfs.ImageBase + dwOffset);

/*
typedef struct _IMAGE_THUNK_DATA32 {
    union {
        DWORD ForwarderString;      // PBYTE 
        DWORD Function;             // PDWORD
        DWORD Ordinal;
        DWORD AddressOfData;        // PIMAGE_IMPORT_BY_NAME
    } u1;
} IMAGE_THUNK_DATA32;
typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;
*/
	
	// i 标志着要加入数据的第几行
	i = 0;
	while (0 != pTD->u1.AddressOfData)
	{
		memset(&lvItem, 0, sizeof(LVITEMA));
		lvItem.mask = LVIF_TEXT;
		lvItem.iItem = i;
		lvItem.pszText = szBuffer;

		// 判断，如果高位为1，则存放的为序号
		if (*(PDWORD)pTD & 0x80000000)
		{
			StringCchPrintfA(szBuffer, 128, "%04XH", *(PDWORD)pTD & 0x7FFFFFFF);
			SendDlgItemMessageA(hWnd, IDC_LIST_IMPORTFUNCTIONS, LVM_INSERTITEMA, 0, (LPARAM)&lvItem);
			StringCchPrintfA(szBuffer, 128, "-");
			lvItem.iSubItem = 1;
			SendDlgItemMessageA(hWnd, IDC_LIST_IMPORTFUNCTIONS, LVM_SETITEMA, 0, (LPARAM)&lvItem);
		}
		// 判断 如果高位为0，则存放的为函数的名字
		else
		{
			Rva2offset(mfs.ImageBase, *(PDWORD)pTD, &dwOffset);
			pIBN = (PIMAGE_IMPORT_BY_NAME)((DWORD)mfs.ImageBase + dwOffset);
			StringCchPrintfA(szBuffer, 128, "%04XH", pIBN->Hint);
			SendDlgItemMessageA(hWnd, IDC_LIST_IMPORTFUNCTIONS, LVM_INSERTITEMA, 0, (LPARAM)&lvItem);
			StringCchPrintfA(szBuffer, 128, "%s", pIBN->Name);
			lvItem.iSubItem = 1;
			SendDlgItemMessageA(hWnd, IDC_LIST_IMPORTFUNCTIONS, LVM_SETITEMA, 0, (LPARAM)&lvItem);
		}
		
		i++;
		pTD++;
	}
}