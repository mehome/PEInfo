可选头 31 个字段
IMAGE_OPTIONAL_HEADER32
Optional_Header
    //
    // Standard fields.
    //
    WORD    Magic;
    BYTE    MAJORLINKERVERSION;
    BYTE    MINORLINKERVERSION;
    DWORD   SIZEOFCODE;
    DWORD   SIZEOFINITIALIZEDDATA;
    DWORD   SIZEOFUNINITIALIZEDDATA;
    DWORD   ADDRESSOFENTRYPOINT;
    DWORD   BASEOFCODE;
    DWORD   BASEOFDATA;

    //
    // NT additional fields.
    //

    DWORD   ImageBase;
    DWORD   SectionAlignment;
    DWORD   FileAlignment;
    WORD    MajorOperatingSystemVersion;
    WORD    MinorOperatingSystemVersion;
    WORD    MajorImageVersion;
    WORD    MinorImageVersion;
    WORD    MajorSubsystemVersion;
    WORD    MinorSubsystemVersion;
    DWORD   Win32VersionValue;
    DWORD   SizeOfImage;
    DWORD   SizeOfHeaders;
    DWORD   CheckSum;
    WORD    Subsystem;
    WORD    DllCharacteristics;
    DWORD   SizeOfStackReserve;
    DWORD   SizeOfStackCommit;
    DWORD   SizeOfHeapReserve;
    DWORD   SizeOfHeapCommit;
    DWORD   LoaderFlags;
    DWORD   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
	
文件头 7 个字段
typedef struct _IMAGE_FILE_HEADER {
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;


IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER)        \
    ((ULONG_PTR)(ntheader) +                                            \
     FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +                 \
     ((ntheader))->FileHeader.SizeOfOptionalHeader   \
    ))

#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory Info
#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory Info
#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory
#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory
#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table RELOCATION_TABLE
#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory
//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)
#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP
#define IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers
#define IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table
#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors
#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor

在DataDirectory 对话框中，可以添加如下几个按扭：
1. 导出表 2.导入表 3.资源表 4.重定位表

typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    union {
        DWORD   Characteristics;            // 0 for terminating null import descriptor
        DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
    } DUMMYUNIONNAME;
    DWORD   TimeDateStamp;                  // 0 if not bound,
                                            // -1 if bound, and real date\time stamp
                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
                                            // O.W. date/time stamp of DLL bound to (Old BIND)

    DWORD   ForwarderChain;                 // -1 if no forwarders
    DWORD   Name;
    DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)
} IMAGE_IMPORT_DESCRIPTOR;

typedef struct _IMAGE_EXPORT_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Name;
    DWORD   Base;
    DWORD   NumberOfFunctions;
    DWORD   NumberOfNames;
    DWORD   AddressOfFunctions;     // RVA from base of image
    DWORD   AddressOfNames;         // RVA from base of image
    DWORD   AddressOfNameOrdinals;  // RVA from base of image
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;


// 目前都临时使用的结构体
typedef struct _IMAGE_BASE_RELOCATION {
    DWORD   VirtualAddress;
    DWORD   SizeOfBlock;
//  WORD    TypeOffset[1];
} IMAGE_BASE_RELOCATION;
typedef IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION;


//将解析出来的重定位表信息写入文件
void PETool::print_BaseRelocation()
{
    fprintf(fp_peMess, "重定位表(Relocation):\n");
    if(dataDir[5].VirtualAddress == 0){
        fprintf(fp_peMess, "\t不存在重定位表!\n");
        return;
    }
    BYTE secName[9] = {0};
    //rec指向重定位表第一个IMAGE_BASE_RELOCATION结构体，获取对应的文件偏移地址
    IMAGE_BASE_RELOCATION * rec = (IMAGE_BASE_RELOCATION *)(pFileBuffer + RVAToFOA(dataDir[5].VirtualAddress));
	
	// 结束，如果为0，则结束此偏移
    for(int i = 1; rec->SizeOfBlock && rec->VirtualAddress; i++){
        DWORD foa = RVAToFOA(rec->VirtualAddress);
        DWORD size = (rec->SizeOfBlock - 8) / 2;
		
        //确定该结构体所处节，并获取节名称
        IMAGE_SECTION_HEADER * section = section_header;
        for(int t = 0; t < sectionNum; t++){
            DWORD lower = RVAToFOA(section[t].VirtualAddress);
            DWORD upper = RVAToFOA(section[t].VirtualAddress) + section[t].Misc.VirtualSize;
            if(foa >= lower && foa <= upper){
                memcpy(secName, section[t].Name, 8);
                break;
            }
        }
		
        //打印该页主要信息
        fprintf(fp_peMess, "\tIndex[%d]\tsection[%s]\tOffset[%08X]\tItems[%dD:%XH]\t【Block】\n", i, secName, foa, size, size);

        //打印一个页中所有重定位地址与信息
        WORD * recAddr = (WORD *)((BYTE *)rec + 8);//recAddr指向重定位表结构体后的首字节
        fprintf(fp_peMess, "\t\tindex\toffset\t\ttype\t【Block Items】\n");
		// 这的size标记着一共有多少个块
        for(DWORD j = 0; j < size; j++){
            DWORD offset = (recAddr[j] & 0X0FFF) + foa;//低四位是偏移地址
            WORD type = recAddr[j] >> 12;//高四位是有效判断位
			
			// 如果高4位为0，则此重定位信息无效
            if(type == 0){
                fprintf(fp_peMess, "\t\t[%d] \t[--------]\tABSOLUTE[%d]\n", j+1, type);
                continue;
            }
            fprintf(fp_peMess, "\t\t[%d] \t[%08X]\tHIGHLOW[%d]\n", j+1, offset, type);
        }
        memset(secName, 0, 9);
		
		//进行下一页的判断
        rec = (IMAGE_BASE_RELOCATION *)((BYTE *)rec + rec->SizeOfBlock);
    }
}

上一个list为三项，分别为VA size item，item部分为节表名称